package ru.ravel.telegramservice.service

import com.pengrad.telegrambot.*
import com.pengrad.telegrambot.model.Update
import com.pengrad.telegrambot.model.request.InlineKeyboardButton
import com.pengrad.telegrambot.model.request.InlineKeyboardMarkup
import com.pengrad.telegrambot.model.request.ParseMode
import com.pengrad.telegrambot.request.DeleteMessage
import com.pengrad.telegrambot.request.EditMessageText
import com.pengrad.telegrambot.request.SendMessage
import com.pengrad.telegrambot.response.SendResponse
import org.slf4j.Logger
import org.slf4j.LoggerFactory
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.stereotype.Service
import ru.ravel.core.dto.ParseInfo
import ru.ravel.telegramservice.dto.Command
import ru.ravel.telegramservice.dto.State
import ru.ravel.telegramservice.entity.TelegramUser
import ru.ravel.telegramservice.repository.TelegramUserRepository

@Service
class TelegramService {

	private Logger logger = LoggerFactory.getLogger(this.class)

	private TelegramBot bot

	@Autowired
	private TelegramUserRepository repository

	@Autowired
	private PriceCheckerService checkerService

	TelegramService() {
		bot = new TelegramBot(System.getenv("bot_token"))
		bot.setUpdatesListener(listener, exceptionHandler)
	}


	private UpdatesListener listener = new UpdatesListener() {

		@Override
		int process(List<Update> updates) {
			try {
				updates.each { update ->
					Long telegramId
					TelegramUser telegramUser

					if (update?.message()) {
						telegramId = update.message().from().id()
						telegramUser = repository.getByTelegramId(telegramId)

						if (telegramUser == null) {
							telegramUser = repository.save(new TelegramUser(telegramId))
						}
						String messageText = update.message().text()
						telegramUser.lastUserMessageId = update.message().messageId()
						repository.save(telegramUser)

						if (update?.message()?.text() && messageText.startsWith('/')) {
							switch (Command.getByCommand(messageText)) {
								case Command.START -> {
									sendGreetingMessage(telegramId)
								}
							}
						} else {
							if (telegramUser.parseInfo == null) {
								telegramUser.parseInfo = new ParseInfo()
							}
							stateWorker(telegramUser, messageText)
						}
					} else if (update?.callbackQuery()) {
						telegramId = update.callbackQuery().from().id()
						telegramUser = repository.getByTelegramId(telegramId)
						handleCallback(update, telegramUser)
					}
				}
			} catch (e) {
				logger.error(e.message, e)
			}
			return UpdatesListener.CONFIRMED_UPDATES_ALL
		}
	}


	void stateWorker(TelegramUser telegramUser, String messageText) {
		String text = switch (telegramUser.currentState) {
			case State.LINK_ADDING -> {
				telegramUser.parseInfo.url = messageText
				PriceCheckerService.Result info = checkerService.getInfo(messageText)
				if (info.isHavingParser) {
					deleteMessage(telegramUser.telegramId, telegramUser.lastBotMessageId)
					telegramUser.currentState = State.NONE
					SendMessage request = new SendMessage(telegramUser.telegramId,
							"<b>–ì–æ—Ç–æ–≤–æ!</b>\n\n${info.result.name}\n\n${info.result.price}")
							.parseMode(ParseMode.HTML)
					sendMessage(request, telegramUser.telegramId)
					sendGreetingMessage(telegramUser.telegramId)
					""
				} else {
					telegramUser.currentState = State.NAME_ADDING
					logger.debug(messageText) /*URL*/
					editMessage(telegramUser.telegramId,
							telegramUser.lastBotMessageId,
							"–ü—Ä–∏—à–ª–∏ <u>—Å—Å—ã–ª–∫—É</u> –Ω–∞ —Ç–æ–≤–∞—Ä\n<b><i>$messageText</i></b> - –ø—Ä–∏–Ω—è—Ç–æ‚úÖ")
					"<b>–ü–∞—Ä—Å–µ—Ä –Ω—É–∂–æ –Ω–∞—Å—Ç—Ä–æ–∏—Ç—å</b>\n–ü—Ä–∏—à–ª–∏ <i><u>–ø–æ–ª–Ω–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ</u></i> —Ç–æ–≤–∞—Ä–∞ —Å–æ —Å—Ç—Ä–∞–Ω–∏—Ü—ã"
				}
			}

			case State.NAME_ADDING -> {
				telegramUser.parseInfo.name = messageText
				telegramUser.currentState = State.PRICE_ADDING
				logger.debug(messageText) /*Name*/
				editMessage(telegramUser.telegramId,
						telegramUser.lastBotMessageId,
						"""
						|–ü—Ä–∏—à–ª–∏ <i><u>–ø–æ–ª–Ω–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ</u></i> —Ç–æ–≤–∞—Ä–∞ —Å–æ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
						|<b><i>$messageText</i></b> - –ø—Ä–∏–Ω—è—Ç–æ‚úÖ
						""".stripMargin())
				"–ù–∞–ø–∏—à–∏ —Ü–µ–Ω—É —ç—Ç–æ–≥–æ —Ç–æ–≤–∞—Ä–∞ —Å–µ–π—á–∞—Å"
			}

			case State.PRICE_ADDING -> {
				telegramUser.parseInfo.price = messageText
				PriceCheckerService.Result info = checkerService.getInfo(telegramUser.parseInfo)
				if (info.isHavingParser) {
					editMessage(telegramUser.telegramId,
							telegramUser.lastBotMessageId,
							"–ù–∞–ø–∏—à–∏ —Ü–µ–Ω—É —ç—Ç–æ–≥–æ —Ç–æ–≤–∞—Ä–∞ —Å–µ–π—á–∞—Å\n<b><i>$messageText</i></b> - –ø—Ä–∏–Ω—è—Ç–æ‚úÖ")
					telegramUser.currentState = State.NONE
					logger.debug(messageText) /*Price*/
					SendMessage request = new SendMessage(telegramUser.telegramId,
							"<b>–ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ø–µ—Ä—Å–µ—Ä–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞!</b>\n\n${info.result.name}\n\n${info.result.price}")
							.parseMode(ParseMode.HTML)
					sendMessage(request, telegramUser.telegramId)
					sendGreetingMessage(telegramUser.telegramId)
				}
				""
			}
			case State.NONE -> throw new IllegalStateException()
			case State.SHOW_ITEMS -> throw new IllegalStateException()
		}
		repository.save(telegramUser)
		if (telegramUser.currentState != State.NONE) {
			SendMessage request = new SendMessage(telegramUser.telegramId, text)
					.parseMode(ParseMode.HTML)
			sendMessage(request, telegramUser.telegramId)
		}
	}


	void sendGreetingMessage(Long telegramId) {
		String text = """
				|–ü—Ä–∏–≤–µ—Ç —ç—Ç–æ <i><u>PriceCheckerBot</u></i>
				|–≠—Ç–æ—Ç –±–æ—Ç –ø–æ–º–æ–≥–∞–µ—Ç –æ—Ç—Å–ª–µ–¥–∏—Ç—å <b>–∏–∑–º–µ–Ω–µ–Ω–∏–µ —Ü–µ–Ω</b> –Ω–∞ –∏–Ω—Ç–µ—Ä–µ—Å—É—é—â–∏–µ –≤–∞—Å —Ç–æ–≤–∞—Ä—ã
				""".stripMargin()
		SendMessage request = new SendMessage(telegramId, text)
				.parseMode(ParseMode.HTML)
				.replyMarkup(new InlineKeyboardMarkup([
						new InlineKeyboardButton("–î–æ–±–∞–≤–∏—Ç—å itemüíé").callbackData(State.LINK_ADDING.name()),
						new InlineKeyboardButton("–ü–æ—Å–º–æ—Ç—Ä–µ—Ç—å –º–æ–∏ –∑–∞–ø–∏—Å–∏ üóíÔ∏è").callbackData(State.SHOW_ITEMS.name())
				] as InlineKeyboardButton[]))
		sendMessage(request, telegramId)
	}

	private ExceptionHandler exceptionHandler = new ExceptionHandler() {
		@Override
		void onException(TelegramException e) {
			if (e.response() != null) {
				logger.error(e.response().errorCode().toString())
				logger.error(e.response().description())
			} else {
				logger.error(e.printStackTrace())
			}
		}
	}

	private Callback<SendMessage, SendResponse> callback = new Callback<SendMessage, SendResponse>() {
		@Override
		void onResponse(SendMessage request, SendResponse response) {
			logger.debug("callback: onResponse")
		}

		@Override
		void onFailure(SendMessage request, IOException e) {
			logger.debug("callback: onFailure")
		}
	}

	private void handleCallback(Update update, TelegramUser telegramUser) {
		String callData = update.callbackQuery().data()
		telegramUser.callbackQueryId = update.callbackQuery().id()
		telegramUser.lastBotMessageId = update.callbackQuery().message().messageId()
		repository.save(telegramUser)

		if (!callData.startsWith("del") && !callData.startsWith("back")) {
			switch (State.valueOf(callData)) {
				case State.LINK_ADDING -> {
					String text = "–ü—Ä–∏—à–ª–∏ <u>—Å—Å—ã–ª–∫—É</u> –Ω–∞ —Ç–æ–≤–∞—Ä"
					telegramUser.currentState = State.LINK_ADDING
					repository.save(telegramUser)
					editMessage(telegramUser.telegramId, telegramUser.lastBotMessageId, text)
				}

				case State.SHOW_ITEMS -> {
					ArrayList<String> items = ["iPhone 11 Pro", "Samsung S24 Ultra", "–ö–∞–∑–∞–Ω—Ç–∏–ø 2009",
											   "–ó–∞–≤–æ–¥ –ø–æ –ø—Ä–æ–∏–∑–≤–æ–¥—Å—Ç–≤—É –∞–ª—é–º–∏–Ω–∏–µ–≤—ã—Ö –≤–µ–¥–µ—Ä", "–ö–∞–∑–∞—Ö–∏", "–ù–∞–≥–µ—Ç—Å—ã", "–®–∏–Ω—ã 12\""]
					String text = "<i><b>–¢–≤–æ–∏ –∑–∞–ø–∏—Å–∏:</b></i>\n\n"
					for (item in items) {
						Integer itemCount = items.indexOf(item) + 1
						text += "$itemCount. $item\n"
					}
					editMessage(telegramUser.telegramId, telegramUser.lastBotMessageId, text, itemsKeyboard(items))
				}

				default -> {
				}
			}
		} else if (callData.startsWith("del")) {
			logger.debug(callData) /*—Ç—É—Ç –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å —É–¥–∞–ª–µ–Ω–∏–µ –∑–∞–ø–∏—Å–∏*/
		} else if (callData.startsWith("back")) {
			deleteMessage(telegramUser.telegramId, telegramUser.lastBotMessageId)
			sendGreetingMessage(telegramUser.telegramId)
		}
	}

	static InlineKeyboardMarkup itemsKeyboard(ArrayList<String> items) {
		def buttons = items.collect { item ->
			new InlineKeyboardButton("‚ùå ${items.indexOf(item) + 1}")
					.callbackData("del=${items.indexOf(item) + 1}")
		}
		def inlineKeyboard = new InlineKeyboardMarkup()
		def row = []
		buttons.each { button ->
			row.add(button)
			if (row.size() == 3) {
				inlineKeyboard.addRow(row as InlineKeyboardButton[])
				row = []
			}
		}
		if (!row.isEmpty()) {
			inlineKeyboard.addRow(row as InlineKeyboardButton[])
		}
		inlineKeyboard.addRow(new InlineKeyboardButton("–ù–∞–∑–∞–¥")
				.callbackData("back"))
		return inlineKeyboard
	}

	void deleteMessage(Long telegramId, Integer messageId) {
		DeleteMessage deleteMessage = new DeleteMessage(telegramId, messageId)
		bot.execute(deleteMessage)
	}

	void editMessage(Long telegramId,
					 Integer messageId,
					 String text,
					 InlineKeyboardMarkup keyboard = null) {
		EditMessageText editedMessage = new EditMessageText(telegramId, messageId, text)
				.parseMode(ParseMode.HTML)
		if (keyboard) {
			editedMessage.replyMarkup(keyboard)
		}
		bot.execute(editedMessage)
	}

//	–≠—Ç–æ —Ç–æ—Ç —Å–∞–º—ã–π popup alert (—Ç–æ–ª—å–∫–æ –≤–æ—Ç –∑–∞—é–∑–∞—Ç—å —è –µ–≥–æ –Ω–µ —Å–º–æ–≥)
//	void showAlert(TelegramUser telegramUser) {
//		AnswerCallbackQuery request = new AnswerCallbackQuery(telegramUser.callbackQueryId)
//				.text("–ù–∞—Å—Ç—Ä–æ–π–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞")
//				.showAlert(true)
//		bot.execute(request)
//	}

	void sendMessage(SendMessage request, Long telegramId) {
		SendResponse response = bot.execute(request)
		TelegramUser telegramUser
		telegramUser = repository.getByTelegramId(telegramId)
		telegramUser.lastBotMessageId = response.message().messageId()
		repository.save(telegramUser)
	}

}
